
* Data hiding can be divided into two primary components:

	Encapsulation
	Abstraction


-------------------- Encapsulation  ----------------

* Encapsulation in OOP refers to binding data and the methods to manipulate that data together in a single unit, that is, class.

* Advantages of encapsulation
	Classes make the code easy to change and maintain.
	Properties to be hidden can be specified easily.
	We decide which outside classes or functions can access the class properties.	


* getter / setter
	class User:
	    def __init__(self, username=None):  # defining initializer
	        self.__username = username

	    def setUsername(self, x):
	        self.__username = x

	    def getUsername(self):
	        return (self.__username)


	Steve = User('steve1')
	print('Before setting:', Steve.getUsername())
	Steve.setUsername('steve2')
	print('After setting:', Steve.getUsername())	



---------------------- Understanding Encapsulation Using Examples -------------------------------
class User:
    def __init__(self, userName=None, password=None):
        self.__userName = userName
        self.__password = password

    def login(self, userName, password):
        if ((self.__userName.lower() == userName.lower())
                and (self.__password == password)):
            print(
                "Access Granted against username:",
                self.__userName.lower(),
                "and password:",
                self.__password)
        else:
            print("Invalid Credentials!")


# created a new User object and stored the password and username
Steve = User("Steve", "12345")
Steve.login("steve", "12345")  # Grants access because credentials are valid

# does not grant access since the credentails are invalid
Steve.login("steve", "6789")
Steve.__password  # compilation error will occur due to this line



	